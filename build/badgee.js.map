{"version":3,"sources":["../src/badgee.js","../src/utils.js","../src/console.js","../src/config.js","../src/store.js","../src/styles.js"],"names":["__guard__","value","transform","undefined","const","noop","extend","destObj","i","args","obj","key","hasOwnProperty","val","console","this","checkConsoleMethods","methodList","ret","method","properties","push","methods","unformatableMethods","defaults","enabled","styled","config","configure","conf","Store","_store","prototype","add","name","get","list","Object","keys","each","func","store","defaultsStyle","border-radius","padding","margin","color","styles","style","stringForStyle","result","k","v","item","join","black","background","currentConf","filter","include","exclude","concatLabelToOutput","out","label","hasStyle","argsForBadgee","parentName","let","parent","badgee","_disable","_defineMethods","length","isntInclusive","test","isExclusive","bind","ref","apply","concat","Array","from","map","prop","Badgee","define","b","redefineMethodsForAllBadges","defaultStyle","x","none","matcher","log","e","fallback","styleDefaults","b$1"],"mappings":"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","file":"badgee.js","sourcesContent":["/* eslint-disable no-console */\n/*! badgee v1.2.0 - MIT license */\nimport { noop } from './utils.js'\nimport console, {\n  properties, methods, unformatableMethods\n} from './console.js'\nimport config from './config';\nimport Store from './store';\nimport styles from './styles';\n\nlet currentConf = config();\nconst store     = new Store;\n\nlet filter = {\n  include : null,\n  exclude : null\n};\n\n// concat foramted label for badges output\n// (i.e. \"%cbadge1%cbadge2\" with style or \"[badge1][badge2] without style\")\nconst concatLabelToOutput = function(out, label, hasStyle){\n  if (out == null) { out = ''; }\n  if (hasStyle == null) { hasStyle = false; }\n  return `${out}${\n    hasStyle ? '%c' : '['\n  }${label}${\n    !hasStyle ? ']' : ''\n  }`;\n};\n\n// Given a label, style and parentName, generate the full list of arguments to\n// pass to console method to get a foramted output\nvar argsForBadgee = function(label, style, parentName) {\n  let args = [];\n\n  if (!currentConf.styled) { style = false; }\n  if (parentName) {\n    const parent = store.get(parentName);\n    args = argsForBadgee(parent.badgee.label, parent.style, parent.parent);\n  }\n\n  if (label) {\n    args[0] = concatLabelToOutput(args[0], label, !!style);\n  }\n\n  if (style) {\n    args.push(styles.stringForStyle(style));\n  }\n\n  return args;\n};\n\n// Define empty Badgee methods\n// Intended to be called in a 'Badgee' instance context (e.g. with 'bind()')\nconst _disable = function() {\n  for (const i in methods) {\n    const method = methods[i]\n    this[method] = noop;\n  }\n  for (const i in unformatableMethods) {\n    const method = unformatableMethods[i];\n    this[method] = noop;\n  }\n};\n\n\n// Define Badgee methods form console object\n// Intended to be called in a 'Badgee' instance context (e.g. with 'bind()')\nconst _defineMethods = function(style, parentName) {\n\n  if (!currentConf.enabled) {\n    return _disable.bind(this)();\n  } else {\n    // get arguments to pass to console object\n    const args = argsForBadgee(this.label, style, parentName);\n\n    // Reset style for FF :\n    // Defining a last style to an unknown property seems to reset to the default\n    // behavior on FF\n    if (style && (args.length > 1)) {\n      args[0] += '%c';\n      args.push('p:a');\n    }\n\n    const isntInclusive = (filter.include != null) && !filter.include.test(args[0]);\n    const isExclusive   = filter.exclude != null ? filter.exclude.test(args[0]) : undefined;\n    if (isntInclusive || isExclusive) {\n      _disable.bind(this)();\n    } else {\n      // Define Badgee 'formatable' methods form console object\n      for (const i in methods) {\n        const method = methods[i]\n        this[method] = console[method].bind(console, ...Array.from(args));\n      }\n\n      // Define Badgee 'unformatable' methods form console object\n      for (const i in unformatableMethods) {\n        const method = unformatableMethods[i];\n        this[method] = console[method].bind(console);\n      }\n    }\n\n    // Define Badgee properties from console object\n    return properties.map((prop) => (this[prop] = console[prop]));\n  }\n};\n\n// ==================================\n\nclass Badgee {\n\n  constructor(label, style, parentName) {\n    // Define Badgee methods form console object\n    this.label = label;\n    _defineMethods.bind(this, style, parentName)();\n\n    // Store instance for later reference\n    store.add(this.label, {\n      badgee: this,\n      style,\n      parent: parentName\n    });\n  }\n\n  // Defines a new Badgee instance with @ as parent Badge\n  define(label, style) {\n    return new Badgee(label, style, this.label);\n  }\n}\n\n// ==================================\n\n// Create public Badgee instance\nlet b = new Badgee;\n\nconst redefineMethodsForAllBadges = () =>\n  store.each((label, b) => _defineMethods.bind(b.badgee, b.style, b.parent)())\n;\n\n// Augment public instance with utility methods\nb.style         = styles.style;\nb.defaultStyle  = styles.defaults;\nb.get           = label => __guard__(store.get(label), x => x.badgee);\nb.filter        = {\n  none() {\n    filter = {\n      include   : null,\n      exclude : null\n    };\n    redefineMethodsForAllBadges();\n    return b.filter;\n  },\n\n  include(matcher) {\n    if (matcher == null) { matcher = null; }\n    if (matcher !== filter.include) {\n      filter.include   = matcher;\n      redefineMethodsForAllBadges();\n    }\n    return b.filter;\n  },\n\n  exclude(matcher) {\n    if (matcher == null) { matcher = null; }\n    if (matcher !== filter.exclude) {\n      filter.exclude = matcher;\n      redefineMethodsForAllBadges();\n    }\n    return b.filter;\n  }\n};\n\nb.config      = function(conf) {\n  currentConf = config(conf);\n  // when conf is updated, redefine every badgee method\n  if (conf) {\n    redefineMethodsForAllBadges();\n  }\n  return currentConf;\n};\n\n// Some browsers don't allow to use bind on console object anyway\n// fallback to default if needed\ntry {\n  b.log();\n} catch (e) {\n  const fallback = console;\n  fallback.define = () => console;\n  fallback.style  = b.style;\n  fallback.styleDefaults = b.styleDefaults;\n  fallback.filter = b.filter;\n  fallback.get    = () => console;\n  fallback.config = () => b.config;\n  b = fallback;\n}\n\nexport default b;\n\n\nfunction __guard__(value, transform) {\n  return (typeof value !== 'undefined' && value !== null) ? transform(value) : undefined;\n}\n","export const noop = () => {};\n\nexport const extend = (destObj, ...args) => {\n  for (const i in args) {\n    const obj = args[i];\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const val = obj[key];\n        destObj[key] = val;\n      }\n    }\n  }\n  return destObj\n}\n","import { noop } from './utils.js'\n// Homogeneisation of the console API on different browsers\n//  - add compat console object if not available\n//  - some methods might not be defined. fake them with `noop` function\n//  - some \"methods\" might not be functions but properties (eg. profile & profileEnd in IE11)\n\nconst console = this.console || {};\n\nconst checkConsoleMethods = (methodList) => {\n  const ret = [];\n  for (const i in methodList) {\n    const method = methodList[i]\n    if (!console[method]) {\n      console[method] = noop;\n      ret.push(method);\n    } else if (typeof console[method] !== 'function') {\n      properties.push(method);\n    } else {\n      ret.push(method);\n    }\n  }\n  return ret;\n};\n\n// For the record, every single console methods and properties\n// [\"memory\", \"exception\", \"debug\", \"error\", \"info\", \"log\", \"warn\", \"dir\",\n// \"dirxml\", \"table\", \"trace\", \"assert\", \"count\", \"markTimeline\", \"profile\",\n// \"profileEnd\", \"time\", \"timeEnd\", \"timeStamp\", \"timeline\", \"timelineEnd\",\n// \"group\", \"groupCollapsed\", \"groupEnd\", \"clear\"]\nconst properties = [\n  'memory'\n];\n\nconst methods = checkConsoleMethods([\n  'debug', 'dirxml', 'error', 'group',\n  'groupCollapsed', 'info', 'log', 'warn'\n]);\n\nconst unformatableMethods = checkConsoleMethods([\n  'assert', 'clear', 'count', 'dir', 'exception', 'groupEnd', 'markTimeline',\n  'profile', 'profileEnd', 'table', 'trace', 'time', 'timeEnd', 'timeStamp',\n  'timeline', 'timelineEnd'\n]);\n\nexport {\n  properties,\n  methods,\n  unformatableMethods\n}\nexport default console\n","import { extend } from './utils';\n\n// default configuration\nconst defaults = {\n  enabled : true,\n  styled  :  true\n};\n\nlet config = extend({}, defaults);\n\nconst configure = function(conf) {\n  // update conf\n  if (typeof conf === 'object') {\n    config = extend({}, defaults, conf);\n  }\n\n  // return current conf\n  return config;\n};\n\nexport default configure\n","class Store {\n  constructor() {\n    this._store = {};\n  }\n\n  // Add object to store\n  add(name, obj) {\n    this._store[name] = obj;\n  }\n\n  // get obj from store\n  get(name) {\n    return this._store[name] || null\n  }\n\n  list() {\n    return Object.keys(this._store);\n  }\n\n  each(func) {\n    for (const name in this._store) {\n      const obj = this._store[name];\n      func(name, obj);\n    }\n  }\n}\n\nexport default Store;\n","import Store from './store';\nimport { extend } from './utils';\n\n// Create store to save styles\nconst store = new Store;\n\n// Default properties for styles\nlet defaultsStyle = {\n  'border-radius': '2px',\n  'padding'      : '1px 3px',\n  'margin'       : '0 1px',\n  'color'        : 'white'\n};\n\nconst styles = {\n  // define a new style or list existing ones\n  style(name, style) {\n    if (name != null && style != null) {\n      style = extend({}, defaultsStyle, style);\n      store.add(name, style);\n    }\n    else if (name != null) {\n      return store.get(name);\n    }\n    return store.list();\n  },\n\n  defaults(style) {\n    if (style != null) {\n      defaultsStyle = style;\n    }\n    return defaultsStyle;\n  },\n\n  stringForStyle(name) {\n    const style = store.get(name);\n    return ((() => {\n      const result = [];\n      for (const k in style) {\n        const v = style[k];\n        let item;\n        if (style.hasOwnProperty(k)) {\n          item = `${k}:${v};`;\n        }\n        result.push(item);\n      }\n      return result;\n    })()).join('');\n  }\n};\n\n\n// define a few styles\n\nconst black = {'color': 'black'};\n\nstyles.style('black',   extend({}, {'background': 'black'}));\nstyles.style('blue',    extend({}, {'background': 'blue'}));\nstyles.style('brown',   extend({}, {'background': 'brown'}));\nstyles.style('gray',    extend({}, {'background': 'gray'}));\nstyles.style('green',   extend({}, {'background': 'green'}));\nstyles.style('purple',  extend({}, {'background': 'purple'}));\nstyles.style('red',     extend({}, {'background': 'red'}));\nstyles.style('cyan',    extend({}, black, {'background': 'cyan'}));\nstyles.style('magenta', extend({}, black, {'background': 'magenta'}));\nstyles.style('orange',  extend({}, black, {'background': 'orange'}));\nstyles.style('pink',    extend({}, black, {'background': 'pink'}));\nstyles.style('yellow',  extend({}, black, {'background': 'yellow'}));\n\n\nexport default styles;\n"]}