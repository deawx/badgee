{"version":3,"sources":["../src/utils.js","../src/console.js","../src/config.js","../src/styles.js","../src/filter.js","../src/badgee.js"],"names":["const","noop","each","items","fn","i","_extend","dest","obj","clone","extend","console","this","methods","unformatableMethods","eachFormatableMethod","eachUnformatableMethod","eachMethod","method","defaults","enabled","styled","config","configure","conf","store","defaultsStyle","border-radius","padding","margin","color","styles","name","style","Object","keys","defaultStyle","style2Str","let","res","k","buildStyle","base","bkgColor","background","include","exclude","isFiltered","str","test","getFilter","onFilterChange","none","matcher","argsForBadgee","label","parentName","args","ref","badgee","parent","formatedLabel","push","_defineMethods","bind","apply","concat","Badgee","prototype","define","redefineMethodsForAllBadges","b","get","log","e","filter","b$1"],"mappings":"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","sourcesContent":["export const noop = () => {}\n\nexport const each = (items, fn) => {\n  for (const i in items) {\n    fn(items[i], i)\n  }\n}\n\nconst _extend = (dest, obj) => {\n  for (const i in obj) dest[i] = obj[i]\n  return dest\n}\nexport const clone = (obj) => _extend({}, obj)\nexport const extend = (dest, obj) => _extend(clone(dest), obj)\n","import { noop, each } from './utils.js'\n// Homogeneisation of the console API on different browsers\n//  - add compat console object if not available\n//  - some methods might not be defined. fake them with `noop` function\n\nconst console = this.console || {};\n\n// For the record, every single console methods and properties :\n// [\"memory\", \"exception\", \"debug\", \"error\", \"info\", \"log\", \"warn\", \"dir\",\n// \"dirxml\", \"table\", \"trace\", \"assert\", \"count\", \"markTimeline\", \"profile\",\n// \"profileEnd\", \"time\", \"timeEnd\", \"timeStamp\", \"timeline\", \"timelineEnd\",\n// \"group\", \"groupCollapsed\", \"groupEnd\", \"clear\"]\n//\n// Focus on logging methods and ignore profiling/timeline methods or less used methods\nconst methods             = ['debug', 'error', 'group', 'groupCollapsed', 'info', 'log', 'warn'];\nconst unformatableMethods = ['clear', 'dir', 'groupEnd'];\n\nexport const eachFormatableMethod   = (fn) => { each(methods, fn) }\nexport const eachUnformatableMethod = (fn) => { each(unformatableMethods, fn) }\nexport const eachMethod = (fn) => {\n  eachFormatableMethod(fn)\n  eachUnformatableMethod(fn)\n}\n\neachMethod((method) => {\n  console[method] = console[method] || noop;\n})\n\nexport default console\n","import { clone, extend } from './utils';\n\n// default configuration\nconst defaults = {\n  enabled : true,\n  styled  :  true\n};\n\nlet config = clone(defaults);\n\nconst configure = function(conf) {\n  // update conf\n  if (conf) {\n    config = extend(defaults, conf);\n  }\n\n  // return current conf\n  return config;\n};\n\n// export default configure\nexport { config, configure }\n","import { each, extend } from './utils';\n\n// Create store to save styles\nconst store = {};\n\n// Default properties for styles\nlet defaultsStyle = {\n  'border-radius': '2px',\n  'padding'      : '1px 3px',\n  'margin'       : '0 1px',\n  'color'        : 'white'\n};\n\n// define a new style or list existing ones\nexport const styles = (name, style) => {\n  if (name != null && style != null) {\n    style = extend(defaultsStyle, style);\n    store[name] = style;\n  }\n  else if (name != null) {\n    return store[name];\n  }\n  return Object.keys(store);\n}\n\nexport const defaultStyle = (style) => {\n  if (style != null) {\n    defaultsStyle = style;\n  }\n  return defaultsStyle;\n}\n\nexport const style2Str = (name) => {\n  let res = ''\n  each(store[name], (style, k) => {\n    res += `${k}:${style};`\n  })\n  return res\n}\n\n// define a few styles\nconst buildStyle = (base, bkgColor) => extend(base, {'background': bkgColor})\n\neach(['green', 'red'], (color) => {\n  styles(color, buildStyle({}, color))\n})\nstyles('orange', buildStyle({'color': 'black'}, 'orange'));\n","let include = null\nlet exclude = null\n\nexport const isFiltered = (str) => {\n  return ((include != null) && !include.test(str)) //isntIncluded\n    || ((exclude != null) && exclude.test(str)) // isExcluded\n}\n\nexport const getFilter = (onFilterChange) => {\n  return {\n    none() {\n      include = null\n      exclude = null\n\n      onFilterChange()\n      return this;\n    },\n\n    include(matcher) {\n      if (matcher !== include) {\n        include = matcher\n        onFilterChange()\n      }\n      return this\n    },\n\n    exclude(matcher) {\n      if (matcher !== exclude) {\n        exclude = matcher\n        onFilterChange()\n      }\n      return this\n    }\n  };\n}\n","/* eslint-disable no-console */\n/*! badgee v1.2.0 - MIT license */\nimport { noop, extend, each } from './utils.js'\nimport console, {\n  eachMethod, eachFormatableMethod, eachUnformatableMethod\n} from './console.js'\nimport { config, configure } from './config.js';\nimport { styles, defaultStyle, style2Str } from './styles.js';\nimport { getFilter, isFiltered } from './filter.js';\n\nconst store = {};\n\n// Given a label, style and parentName, generate the full list of arguments to\n// pass to console method to get a foramted output\nconst argsForBadgee = function(label, style, parentName) {\n  let args = [];\n\n  if (parentName) {\n    const [badgee, style, parent] = store[parentName];\n    args = argsForBadgee(badgee.label, style, parent);\n  }\n\n  if (label) {\n    // concat formated label for badges output\n    // (i.e. \"%cbadge1%cbadge2\" with style or \"[badge1][badge2] without style\")\n    const formatedLabel = !style ? `[${label}]` : `%c${label}`\n    args[0] = `${args[0] || ''}${formatedLabel}`\n  }\n\n  if (style) {\n    args.push(style2Str(style));\n  }\n\n  return args;\n};\n\n// Define Badgee methods form console object\n// Intended to be called in a 'Badgee' instance context (e.g. with 'bind()')\nconst _defineMethods = function(style, parentName) {\n  // get arguments to pass to console object\n  const args = argsForBadgee(this.label, config.styled ? style : false, parentName);\n\n  if (!config.enabled || isFiltered(args[0])) {\n    // disable everything\n    eachMethod((method) => this[method] = noop)\n  }\n  else {\n    // Define Badgee 'formatable' methods form console object\n    eachFormatableMethod((method) => {\n      this[method] = console[method].bind(console, ...args);\n    });\n\n    // Define Badgee 'unformatable' methods form console object\n    eachUnformatableMethod((method) => {\n      this[method] = console[method].bind(console);\n    });\n  }\n\n};\n\n// ==================================\n\nclass Badgee {\n\n  constructor(label, style, parentName) {\n    // Define Badgee methods form console object\n    this.label = label;\n    _defineMethods.bind(this, style, parentName)();\n\n    // Store instance for later reference\n    store[label] = [this, style, parentName];\n  }\n\n  // Defines a new Badgee instance with @ as parent Badge\n  define(label, style) {\n    return new Badgee(label, style, this.label);\n  }\n}\n\n// ==================================\n\nconst redefineMethodsForAllBadges = () => {\n  each(store, ([badgee, style, parent]) => {\n    _defineMethods.bind(badgee, style, parent)()\n  })\n}\n\n// Create public Badgee instance\nlet b = new Badgee;\n\n// Augment public instance with getter method\nb.get = (label) => (store[label] || {})[0];\n\n// Some browsers don't allow to use bind on console object anyway\n// fallback to default if needed\ntry {\n  b.log();\n} catch (e) {\n  b = extend(console, {\n    define : () => b,\n    get    : () => b,\n  });\n}\n\n// Augment public instance with a few utility methods\nb.style = styles;\nb.defaultStyle  = defaultStyle;\nb.filter = getFilter(redefineMethodsForAllBadges)\nb.config = function(conf) {\n  // when conf is updated, redefine every badgee method\n  if (conf && typeof conf==='object') {\n    configure(conf)\n    redefineMethodsForAllBadges();\n  }\n  return config;\n};\n\nexport default b;\n"]}